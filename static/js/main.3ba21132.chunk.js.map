{"version":3,"sources":["Message.tsx","Chat.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Message","props","date_moment","isMobile","moment","date","format","className","name","message","Chat","location","useLocation","useState","messageField","setMessageField","latestMessageTime","setLatestMessageTime","latestMessageTimeRef","useRef","current","messageKey","setMessageKey","messageKeyRef","handleSubmitMessage","e","preventDefault","state","Date","now","date_unix","getTime","length","fetch","method","headers","body","JSON","stringify","toString","then","response","json","console","log","sent_message","key","setCurrentMessages","currentMessages","setOpen","useEffect","retrieve_all_messages","rawMessages","setRawMessages","rawMessagesRef","res","data","all_messages","map","message_info","index","retrieve_new_messages","last_message_unix","parseInt","queryString","new_messages","newMessagesJSX","messagesEndRef","scrollIntoView","behavior","height","window","innerHeight","numrows","Math","floor","openSnackBar","interval","setInterval","clearInterval","devButtons","showDevButtons","Container","maxWidth","disableGutters","ref","id","Box","width","TextField","label","fullWidth","multiline","rows","value","onChange","target","variant","color","onKeyDown","Snackbar","anchorOrigin","vertical","horizontal","open","onClose","autoHideDuration","Button","onClick","dateUnix","App","exact","path","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.3ba21132.chunk.js","sourcesContent":["import React,{ ReactElement } from 'react'\nimport moment from 'moment'\nimport { isMobile } from \"react-device-detect\";\n\n// Retrieving message information\nexport interface messageProps {\n\tname: string;\n\tdate: string;\n\tmessage: string;\n}\n\nexport default function Message(props: messageProps):ReactElement {\n\t// Reformat date (conditional on mobile display)\n\tvar date_moment = !isMobile ? moment(props.date).format('D MMMM YYYY  HH:mm:ss') : moment(props.date).format('D/M  HH:mm');\n\n\treturn (\n\t\t<>\n\t\t\t<section className=\"message_container\">\n\t\t\t\t<div className=\"msg_name\"> {props.name} </div>\n\t\t\t\t<div className=\"msg_date\"> {date_moment} </div>\n\t\t\t\t<div className=\"msg_message\"> {props.message} </div>\n\t\t\t</section>\n\t\t</>\n\t)\n}","import React, { useState, SyntheticEvent, useEffect, useRef, useMemo } from 'react';\nimport { Container, Button, TextField, Box, Snackbar } from '@material-ui/core';\nimport './App.css';\nimport { useLocation } from \"react-router-dom\";\nimport Message from \"./Message\";\n\nexport interface chatProps {}  // No props being used right now\n\n// Defining location type to access name state\nexport interface locationProps {\n\tpathname: string;\n\tsearch: string;\n\thash: string;\n\tkey: string;\n\tstate: {name: string};\n}\n\nexport default function Chat(props: chatProps) {\n\t// Retrieve props passed from login\n\tconst location = useLocation() as locationProps;\n\n\tconst [messageField, setMessageField] = useState(\"\");           // Message input field\n\n\tconst [latestMessageTime, setLatestMessageTime] = useState(0);  // Last received/sent message time\n\tconst latestMessageTimeRef = useRef(latestMessageTime);         // Reference\n\tlatestMessageTimeRef.current = latestMessageTime;\n\t\n\tconst [messageKey, setMessageKey] = useState(0);\t\t\t\t// Div keys state\n\tconst messageKeyRef = useRef(messageKey);                       // Reference\n\tmessageKeyRef.current = messageKey;\n\n\t// Send information about input field to backend\n\tconst handleSubmitMessage = (e:SyntheticEvent) => {\n\t\te.preventDefault() // Prevents page from reloading after submitting message\n\n\t\t// Extract message fields\n\t\tconst name = location.state.name;\n\t\tconst date = new Date(Date.now());\n\t\tconst message = messageField;\n\t\tconst date_unix = date.getTime();\n\n\t\t// Send the message with POST request\n\t\tif (messageField.length !== 0 && messageField.length < 1000) {\n\t\t\tfetch(\"/api/send_message\", {\n\t\t\tmethod:\"POST\",\n\t\t\theaders: {\"content_type\":\"application/json\"},\n\t\t\tbody:JSON.stringify(\n\t\t\t\t{ \n\t\t\t\t\"name\": name,\n\t\t\t\t\"date\": date.toString(),\n\t\t\t\t\"message\": message,\n\t\t\t\t\"date_unix\": date_unix                     // Unix timestamp\n\t\t\t\t})\n\t\t\t})\n\t\t\t.then(response => { return response.json()})\n\t\t\tconsole.log(\"Message sent!\")\n\n\t\t\tsetMessageField(\"\")                            // Empty the message container\n\t\t\t// Increment message key and add message locally\n\t\t\tsetMessageKey(messageKeyRef.current+1)\n\t\t\tconst sent_message:any = \n\t\t\t\t<Message\n\t\t\t\t\tkey={messageKeyRef.current}\n\t\t\t\t\tname={name}\n\t\t\t\t\tdate={date.toString()}\n\t\t\t\t\tmessage={message}\n\t\t\t\t/>\n\t\t\tsetCurrentMessages(currentMessages => [...currentMessages, sent_message])\n\t\t\tsetLatestMessageTime(date_unix)  // Update latest message time\n\t\t\treturn false\n\t\t}\n\t\t// Flag down empty/long messages and open snackbar\n\t\telse {\n\t\t\tsetOpen(true);\n\t\t}\n\t}\n\n\t// Enter key functionality for sending messages\n\tconst checkEnterPressed = (e:any) => {\n\t\tif (e.key == \"Enter\") { handleSubmitMessage(e) }\n\t}\n\n\t// Retrieve all messages when page is loaded\n\tuseEffect(()=> {\n\t\tretrieve_all_messages();\n\t}, [])\n\n\tconst [rawMessages, setRawMessages] = useState<string[][]>([[]]);  // All messages in raw JSON format\n\tconst rawMessagesRef = useRef(rawMessages);                        // Reference handling\n\trawMessagesRef.current = rawMessages;\n\n\tconst [currentMessages, setCurrentMessages] = useState<string[][]>([[]]);   // All messages in JSX format\n\n\t// Retrieve all current messages from the server (only really call on first load of page)\n\tfunction retrieve_all_messages() {\n\t\tfetch(\"/api/get_all_messages\", {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\"content_type\":\"application/json\"}\n\t\t})\n\t\t.then((res) => res.json())\n\t\t.then((data) => {\n\t\t\tconsole.log(\"Retrieved all messages from server\");\n\t\t\tsetRawMessages(data.all_messages);                  // Update raw messages\n\t\t\tconst length:number = data.all_messages.length;     // Handle div keys logic \n\t\t\tsetMessageKey(messageKeyRef.current+length);\n\t\t\tsetCurrentMessages(data.all_messages.map((message_info:string[], index:number) => {\n\t\t\t\t// Generate a message component for every message\n\t\t\t\treturn (\n\t\t\t\t\t<Message\n\t\t\t\t\t\tkey={messageKeyRef.current - length + index}\n\t\t\t\t\t\tname={message_info[0]}\n\t\t\t\t\t\tdate={message_info[1]}\n\t\t\t\t\t\tmessage={message_info[2]}\n\t\t\t\t\t/>\n\t\t\t\t)\n\t\t\t}));\n\t\t})\n\t}\n\n\t// Retrieve only messages that the user has not loaded\n\tfunction retrieve_new_messages() {\n\t\t// If no raw messages loaded on client side then retrieve all messages from serverm instead\n\t\tif (!rawMessagesRef.current.length) { \n\t\t\tretrieve_all_messages();\n\t\t\treturn null\n\t\t}\n\t\t// Retrieve unix timestamp of last message user has (latest between user sent and others sent)\n\t\tlet last_message_unix = (parseInt(rawMessagesRef.current[rawMessagesRef.current.length-1][3]) > latestMessageTimeRef.current) ? rawMessagesRef.current[rawMessagesRef.current.length-1][3] : latestMessageTimeRef.current.toString()\n\n\t\t// Defining GET request query\n\t\tconst queryString = `/api/get_new_messages?time=${last_message_unix}`;\n\t\tconsole.log(`Getting new messages with query: ${queryString} for user ${location.state.name}`)\n\n\t\t// Request new messages with query\n\t\tfetch(queryString, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\"content_type\":\"application/json\"}\n\t\t})\n\t\t.then((res) => res.json())\n\t\t.then((data => {\n\t\t\tconsole.log(`Retrieve new messages from server for user ${location.state.name}`)\n\t\t\tconsole.log(\"New messages are:\")\n\t\t\tconsole.log(data.new_messages)\n\t\t\t// Render the new messages if some are retrieved\n\t\t\tif (data.new_messages.length) {\n\t\t\t\tsetRawMessages(rawMessages => [...rawMessages, ...data.new_messages])  // Update raw messsages\n\t\t\t\tconst length = data.new_messages.length;        \t\t\t\t\t   // Handle div keys\n\t\t\t\tsetMessageKey(messageKeyRef.current + length)\n\t\t\t\tconst newMessagesJSX = data.new_messages.map((message_info:string[], index:number) => {\n\t\t\t\t\t// Generate a message component for every message\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<Message\n\t\t\t\t\t\t\tkey={messageKeyRef.current - length + index}\n\t\t\t\t\t\t\tname={message_info[0]}\n\t\t\t\t\t\t\tdate={message_info[1]}\n\t\t\t\t\t\t\tmessage={message_info[2]}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t// Concatenate with currently existing messages\n\t\t\t\tsetCurrentMessages(currentMessages => [...currentMessages, ...newMessagesJSX])\n\t\t\t}\n\t\t}))\n\t}\n\n\t// Handle automatic scrolling down\n\tconst messagesEndRef:any = useRef(null);  // Bottom of messages reference\n\tconst scrollToBottom = () => {\n\t\tmessagesEndRef.current.scrollIntoView({ behavior: \"smooth\" })\n\t};\n\tuseEffect(scrollToBottom, [currentMessages]);\n\n\t// Delete all messages (Developer functionality only)\n\tfunction delete_messages() {\n\t\tfetch(\"/api/clear_messages\", {\n\t\t\tmethod:\"DELETE\",\n\t\t\theaders: {\"content_type\":\"application/json\"}\n\t\t})\n\t\t.then(() => {console.log(\"All messages deleted!\")})\n\t}\n\n\t// Determine number of rows for the chat input box\n\tconst height:number = window.innerHeight;\n\tconst numrows:number = Math.floor(height/200);\n\n\t// Tracks snackbar status\n\tconst [openSnackBar, setOpen] = useState(false);\t \t\n\t// Snackbar close handling\n\tconst closeSnackBar = () => {\n\t\tsetOpen(false)\n\t}\n\n\t// IMPORTANT: Asynchronously queries the server for new messages every second\n\tuseEffect(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tretrieve_new_messages();\n\t\t}, 1000)\n\t\treturn () => clearInterval(interval);\n\t}, []);\n\n\t// State handler for dev button\n\tconst [devButtons, showDevButtons] = useState(false);\n\tfunction open_dev_menu() {\n\t\tconsole.log(\"Dev menu toggled\")\n\t\tshowDevButtons(!devButtons)\n\t}\n\n\t// Send request to delete old messages\n\tfunction delete_old_messages() {\n\t\tconst dateUnix = Date.now();\n\t\tconst queryString = `api/clear_old_messages?time=${dateUnix}`\n\n\t\tfetch(queryString, {\n\t\t\tmethod:\"DELETE\",\n\t\t\theaders: {\"content_type\":\"application/json\"}\n\t\t})\n\t\t.then(() => {console.log(\"Old messages deleted!\")})\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t{/* Main container and section */}\n\t\t\t<Container maxWidth=\"lg\" className=\"large_chat_container\" disableGutters={true}>\n\t\t\t\t<section className=\"chat_container\">\n\n\t\t\t\t\t{/* Div for displaying and deleting chat messages */}\n\t\t\t\t\t<div className=\"chat_messages_container\">\n\t\t\t\t\t\t{/* Div showing all chat messages */}\n\t\t\t\t\t\t<div className=\"chat_messages_div\">\n\t\t\t\t\t\t\t{ currentMessages }\n\t\t\t\t\t\t\t<div ref={messagesEndRef} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Div for chat message input field */}\n\t\t\t\t\t<div id=\"input_field_div\">\n\t\t\t\t\t\t<Box width=\"100%\">\n\t\t\t\t\t\t\t<TextField\n\t\t\t\t\t\t\t\tlabel={`Say something, ${location.state.name} :)`}\n\t\t\t\t\t\t\t\tfullWidth\n\t\t\t\t\t\t\t\tmultiline\n\t\t\t\t\t\t\t\trows={numrows}\n\t\t\t\t\t\t\t\tvalue={messageField}\n\t\t\t\t\t\t\t\tonChange={e => setMessageField(e.target.value)}\n\t\t\t\t\t\t\t\tvariant=\"outlined\"\n\t\t\t\t\t\t\t\tcolor=\"primary\"\n\t\t\t\t\t\t\t\tonKeyDown={checkEnterPressed}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{/* Warning snackbar for invalid message */}\n\t\t\t\t\t<Snackbar\n\t\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\t\tanchorOrigin={{\n\t\t\t\t\t\tvertical: 'bottom',\n\t\t\t\t\t\thorizontal: 'center',\n\t\t\t\t\t\t}}\n\t\t\t\t\t\topen={openSnackBar}\n\t\t\t\t\t\tonClose={closeSnackBar}\n\t\t\t\t\t\tautoHideDuration={3000}\n\t\t\t\t\t\tmessage=\"Your message is either empty or too long!\"\n\t\t\t\t\t/>\n\n\t\t\t\t\t{/* Submit button div */}\n\t\t\t\t\t<div className=\"submit_button_div\"> \n\t\t\t\t\t\t<Button \n\t\t\t\t\t\t\tvariant=\"contained\" \n\t\t\t\t\t\t\tcolor=\"primary\" \n\t\t\t\t\t\t\tclassName=\"submit_button\"\n\t\t\t\t\t\t\tonClick={handleSubmitMessage}\n\t\t\t\t\t\t> \n\t\t\t\t\t\t\t<span id=\"submit_button_text\"> Send </span>\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</div>\n\n\t\t\t\t</section>\n\t\t\t</Container>\n\n\t\t\t<button className=\"hidden_button\" onClick={open_dev_menu}>D</button>\n\t\t\t{devButtons ? <div className=\"dev_buttons_div\">\n\t\t\t\t<button onClick={delete_messages}>DA</button>\n\t\t\t\t<button onClick={delete_old_messages}>DO</button>\n\t\t\t\t<button onClick={retrieve_all_messages}>RA</button>\n\t\t\t\t<button onClick={retrieve_new_messages}>RN</button>\n\t\t\t</div>: null}\n\n\t\t</>\n\t)\n}","import React, { ReactElement, useState } from 'react';\nimport './App.css';\nimport { BrowserRouter as Router, Switch, Route, Link, Redirect } from \"react-router-dom\";\nimport Login from './Login'\nimport Chat from './Chat'\n\nfunction App():ReactElement {\n\tconsole.log('Frontend is now running!');\t\n\n\treturn (\n\t\t// Basice router paths to the login and chat page\n\t\t<>\n\t\t\t<Chat />\n\t\t\t<Router>\n\t\t\t\t<Switch>\n\t\t\t\t\t<Route exact path='/chat'> \n\t\t\t\t\t\t<Chat />\n\t\t\t\t\t</Route>\n\t\t\t\t</Switch>\n\t\t\t</Router>\n\t\t</>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n  ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL!,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost.\n        // Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n              'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n      .register(swUrl)\n      .then((registration) => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          if (installingWorker == null) {\n            return;\n          }\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n                console.log(\n                    'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n                );\n\n                // Execute callback\n                if (config && config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n\n                // Execute callback\n                if (config && config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch((error) => {\n        console.error('Error during service worker registration:', error);\n      });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'},\n  })\n      .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n        const contentType = response.headers.get('content-type');\n        if (\n          response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n        ) {\n        // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then((registration) => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n        // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n            'No internet connection found. App is running in offline mode.',\n        );\n      });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n        .then((registration) => {\n          registration.unregister();\n        })\n        .catch((error) => {\n          console.error(error.message);\n        });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}